/* змейка храниться в виде стека (т.е. элементы добавляются в начало) */#include <stdlib.h>#include <stdio.h>#include <graphics.h>#include <time.h>struct tle{struct tle *next, *head;int x;int y;} ; // список для хранения змейкиvoid Draw(int x,int y,int c){  // процедура для закрашивания нужных нам координат     setfillstyle( 1,COLOR(100+20*(1-c), 155-35*(1-c), 100+20*(1-c)));     floodfill(20*(x-1)+1, 20*(y-1)+1, 0); }void move(int x,int y,tle* &head,tle* &tail,int c){   // процедура для увеличения и перемещения змейки     tle *p,*d;     // создаем рабочие указатели     p=new tle;    // выделаем память под временный список     p->x=x;       // заполняем его тем, что прислали     p->y=y;     p->next=head;       head->head=p;  // добавляем к основной змейке (в начало) временный список     head=p;        Draw(head->x,head->y,1);   // прорисовывываем координаты     if(c){      // если "еда"          d=tail;           // запоминаем хвост          tail=tail->head;  // прибавляем к голове          Draw(d->x,d->y,0); // рисуем новые координаты          delete d;           tail->next=NULL; // зануляем перед хвостом для невыхода за пределы списка     }}int main(){    srand(time(0));         int i,j,x,y,x0=0,y0=0,flag,gg=0,k=200;   //    tle *p,*head,*tail;  // создаем нужны нам списки (p - вся змейка, head - первый элемент (голова), tail - хвост (в него мы будем добавлять))         initwindow(600,600);   // создаем окно   setfillstyle(1,COLOR(120,120,120));  // закрашиваем окно    setcolor(0);  // задаем цвет квадратов (полос)   floodfill(1,1,15);   // начальная закраска экрана   for(i=0;i<600;i+=20){  // делаем сетку-игровое поле          line (i, 0, i, 600 );          line (0, i, 600, i );   }      x=15; //  начальное положение змейки (измеряется в клетках)   y=15;         p=new tle;   // выделяем память под змейку   p->next=NULL;   // создаем голову   head=tail=p;  // голова и хвост пока, что в одной клетке, т.к. не создано больше ничего   p=new tle;    // выделяем память под ещё одну ячейку   p->next=head; // связываем с головой   head->head=p;   head=p;      Draw(head->x,head->y,0); // выделяем змейку (ее хвост) на игровой поле   Draw(head->next->x,head->next->y,0);   //  выделяем змейку (ее голову) на игровой поле   flag=2;  // в какую сторону движется змея   /* Движение змеи зависит от значения переменной flag:               0-вниз               1-вправо               2-вверх               3-влево    */      while(1){   // бесконечный цикл для передвижения      if(!x0){             x0=rand()%29+2;  // случайные координаты пояления "еды" по X         y0=rand()%29+2;  // случайные координаты пояления "еды" по Y         Draw(x0,y0,1);      // нарисовали "еду"         for(p=head;p;p=p->next)   // продвигаемся по списку для проверки              if(p->x==x0&&p->y==y0) x0=0;   // проверяем, не съели ли эту "еду" :)      }              if(kbhit()){            // если была нажата клавиша         getch();            // смотрим, какая была нажата         switch(getch()){     // реализуем управление стрелочками             case 80: if(flag!=2)flag=0; break;             case 77: if(flag!=3)flag=1; break;             case 72: if(flag!=0)flag=2; break;             case 75: if(flag!=1)flag=3; break;        }     }                                         switch(flag){   // реализуем перемещение (если вниз - прибавляем коорд. по Y, вверх - отнимаем по Y, вправо - прибавляем по X, влево - отнимаем по X)        case 0: y++; break;        case 1: x++; break;        case 2: y--; break;         case 3: x--; break;           }    if(x==31||y==31||x==0||y==0) break;  // если наткнулись на границы поля    for(p=head;p;p=p->next)       // проходим по змейке для проверки      if(p->x==x&&p->y==y) gg=1;   // если змейка уперлась в себя    if(gg) break;                 // останавливаем игру в этом случае      if(x==x0&&y==y0){     // если пришли на точку с "едой"       move(x,y,head,tail,0);  //  увеличиваем змейку       x0=y0=0;          k=k*9/10;continue;       } else       move(x,y,head,tail,1);  // иначе просто перемещаем змейку    delay(k);     // делаем задержку, которая со временем уменьшается  }    getch();          closegraph();      // закрываем игровое окно  system("PAUSE");      return 0;}